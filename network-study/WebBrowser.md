# 웹 브라우저가 메세지를 만든다

## 목차
1. [HTTP 리퀘스트 메세지 작성](#HTTP-리퀘스트-메세지-작성)
2. [웹 서버의 IP 주소를 DNS 서버에 조회](#웹-서버의-IP-주소를-DNS-서버에-조회)
3. [DNS 서버의 연대](#dns-서버의-연대)
4. [프로토콜 스택에 메세지 송신을 의뢰](#프로토콜-스택에-메세지-송신을-의뢰)

## HTTP 리퀘스트 메세지 작성

- URL
  - 네트워크 상에서 자원의 위치를 알리기 위한 규약
  - 도메인명, 경로, 포트번호 등 쓸 수 있음
  - 모든 URL은 맨 앞 문자열에 액세스 프로토콜을 포함함
    - 프로토콜 : 통신 동작의 규약
    - `http:`: 웹 서버, `FTP:`: FTP(파입 업/다운로드) 서버, `mailto:` 메일 ··· etc.

### 브라우저는 URL을 해독한다.
#### URL의 요소
  - `http:` + `\\` + `웹 서버명` + `/` + `디렉토리` + `/` + ··· + `파일명`
  - ✔️ **파일명** 생략 가능
    -  eg) `http://example.com/test/`
    - 서버에 미리 정의해야 함. (대체로 index.html)
  - ✔️ **디렉토리명** 생략 가능
    - eg) `http://example.com`
    - 루트 디렉토리에 미리 설정된 파일에 엑세스
  - ❔`/` 가 없는 경우엔?
    - eg) `http://example.com/test`
      - test라는 디렉토리가 있으면 디렉토리로, 파일이 있으면 파일로 간주함
        - 둘 다 있을 수 없음

### HTTP의 기본 개념
#### HTTP 프로토콜 
  - 클라이언트와 서버가 주고받는 메세지의 내용이나 순서를 정한 것
  - 클라이언트 → 서버 
    - 리퀘스트 메세지를 보냄
      - URI, METHOD
  - 서버 → 클라이언트
    - 응답 메세지를 보냄
      - Status Code
#### Request Message
  - Request Line
    - METHOD
      - GET, POST, PUT, DELETE ··· etc.
    - URI
    - HTTP 버전
  - 메세지 헤더
    - 요청의 부가적인 정보
      - 데이터의 종류, 날짜 ··· etc.
  - 메세지 본문
    - 메소드와 URI만으로 요청을 보낼 수 있는 경우엔 메세지 본문이 없을 수도 있음
#### Response Message
  - Status Line
    - HTTP 버전
    - Status Code
    - | code | desc      |
      |------|-----------|
      | 1XX  | 처리의 경과 상황 |
      | 2XX  | 정상 종료     |
      | 3XX  | 다른 조치 필요  |
      | 4XX  | 클라이언트 오류  |
      | 5XX  | 서버 오류     |

    - Status Message
      - OK, NOT FOUND ··· etc.
  - 메세지 헤더
  - 메세지 본문
    - `Content-Type: text/html`인 경우에 html 태그가 포함될 수 있음
      - 태그 안에 영상/사진 파일이 포함되어 있다면 브라우저는 파일을 읽기 위한 Request를 웹 서버에 보내게 됨.
        - 예를 들어 하나의 응답 메세지에 세 개의 사진이 포함되어 있다면 브라우저는 총 4번의 요청을 보내게 되는 것.


## 웹 서버의 IP 주소를 DNS 서버에 조회

HTTP 메세지를 만들면 브라우저가 OS에게 의뢰한다. (브라우저는 메세지를 네트워크에 송신하는 기능이 없음.) <br>
OS에게 송신을 의뢰할 땐 도메인명이 아닌 IP 주소로 의뢰해야 하므로, <br>
**도메인 명을 기반으로 IP 주소를 조사해야 함.**

### TCP/IP
서브넷을 라우터로 연결하여 전체 네트워크를 이룸
- 서브넷
  - 허브에 몇 대의 컴퓨터가 접속된 것
- 액세스 대상의 서버까지 메세지가 운반되는 과정
  - `메세지 전송` → `허브` → `라우터` → ··· → `허브` → `메세지 도착`


### IP 주소
- IP 주소 = 네트워크 번호 + 호스트 번호
  - 네트워크 번호 : 서브넷에 할당된 번호
  - 호스트 번호 : PC에 할당된 번호
- IP 주소는 8비트 씩 점으로 구분해서 10진수로 표시한 32비트의 디지털 데이터
  - eg) `10.11.12.13`
  - 어느 부분이 네트워크 번호인지 호스트 번호인지 구분하기 어려움
    - 필요에 따라 `넷마스크`라는 IP 주소를 덧붙일 수 있음.
- 호스트 번호 부분의 비트값이 전부 0일 때
  - **서브넷 자체를 의미**
- 호스트 번호 부분의 비트값이 전부 0일 때
  - **서브넷에 연결된 모든 PC에게 패킷 보냄**
- 넷마스크
  - 32비트의 디지털 데이터
  - 왼쪽에 1이 나열되고, 오른쪽에 0이 나열된 구조
    - `1` = **네트워크 번호** / `0` = **호스트 번호** 
    - eg) `11111111.11111111.11111111.00000000`
      - 24비트까지 네트워크 번호, 그 이후엔 호스트 번호라는 뜻
      - 1의 갯수를 10진수로 표현해서 쓰기도 함.
      - 위의 예시는 `24`와 동일한 의미

> 도메인과 IP 주소를 구분해서 쓰는 이유
> - 왜 도메인 대신 IP 주소를 쓸 수 없을까?
>   - 외우기 어렵고 사용성이 낮음
> - 왜 IP 주소 대신 도메인 주소만 쓸 수 없을까?
>   - IP 주소는 32비트, 도메인 주소는 적게는 수십, 많게는 255바이트의 문자를 취급
>   - 네트워크 부하되고 속도와 효율성이 저하됨.

### DNS 서버
- DNS 리졸버
  - 짧게 `리졸버`라고 부르기도 함
  - DNS 서버에 메세지를 보내고 응답 메세지를 받는 역할을 함.
  - `소켓 라이브러리`에 있는 기능
    - OS가 제공하는 기능
- 리졸버를 이용하여 DNS 서버를 조회하는 과정
  1. 브라우저가 리졸버를 호출함.
  2. 리졸버가 요청 메세지를 만듦.
  3. 요청 메세지를 OS의 프로토콜 스택을 통해 전달함.
  4. 프로토콜 스택은 LAN 어댑터를 통해 DNS 서버에게 메세지를 전송.
  5. DNS 서버가 호스트 이름을 IP 주소로 해석하고, 응답 메세지를 생성하여 클라이언트에게 전송.
  6. 프로토콜 스택을 거쳐서 리졸버에게 전달됨.
  7. 리졸버는 IP 주소만 추출해서 브라우저에게 반환.


```agsl
✔️ DNS 서버의 IP는 PC에 미리 설정되어 있다!
```

## DNS 서버의 연대

### DNS 서버의 동작
DNS 서버는 클라이언트에게 조회 메세지를 받고 응답 메세지를 보냄.
조회 메세지에는 다음 세 가지 정보가 포함되어 있음
- 이름
  - 서버나 메일 주소의 이름
- 클래스
  - 인터넷 외의 네트워크까지 고안하여 만든 필드지만, 현재는 인터넷 외엔 소멸되어 이 값은 항상 `IN`임
- 타입
  - 지원되는 정보의 타입
  - 타입에 따라 클라이언트에 회답하는 정보의 내용이 달라짐
  - `A`: IP 주소
  - `MX` : 메일 주소
    - `MX` 타입은 메일 서버의 우선 순위와 메일 서버의 이름이 함께 응답 메세지에 들어있음.
    - 메일 서버의 이름에 해당하는 IP 주소도 함께 응답 됨.


### 도메인의 계층
도메인은 `.`으로 계층을 분리함. 오른쪽으로 갈수록 상위 계층.

eg) 'www.github.com'의 경우
`com`아래에 `github`아래에 `www`가 있다.

### 담당 DNS 서버를 찾는 방법
1. 하위 도메인을 담당하는 DNS 서버의 IP 주소를 상위 DNS 서버에 등록함
2. 상위의 DNS 서버를 또 그 상위의 DNS 서버를 등록함
3. 1과 2 반복
4. 최상위 도메인의 DNS 서버를 루트 도메인 DNS 서버에 등록
   - 루트 도메인에는 도메인 명이 없다.
5. 인터넷에 존재하는 모든 DNS 서버에 루트 도메인의 DNS 서버를 등록한다.

위 작업을 통해 클라이언트가 DNS 서버에 액세스하면 루트 도메인을 경유하여 도메인의 계층 아래로 찾아가서 최종적으로 원하는 DNS 서버에 도착한다.


#### DNS 서버를 찾아가는 과정
- eg) www.github.com 를 찾는다면?

1. 가장 가까운 DNS 서버 'A'에게 `www.github.com`를 찾는 조회 메세지를 보냄.
2. 'A'는 루트 도메인의 DNS 서버에게 받은 조회 메세지를 전송함.
3. 루트 도메인은 조회하는 주소가 `com` 도메인 아래 있다는 것을 확인 후 `com` 도메인의 DNS 서버의 주소를 반송함.
4. 'A'는 `com` DNS 서버에게 `www.github.com`를 찾는 조회 메세지를 보냄.
5. `com` DNS 서버는 조회하는 주소가 `github` 도메인 아래 있다는 것을 확인 후 `github` 도메인의 DNS 서버의 주소를 반송함.
6. 3-5 반복.
7. 원하는 DNS 서버에 도달한 후 IP 주소를 찾아서 클라이언트에게 회답함.

하지만 현실에선 한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있어서 위의 예시처럼 각 도메인의 한 대씩 DNS 서버가 존재한다고 단정할 수 없음.<br/>
상위와 하위의 도메인을 같은 DNS 서버에 등록할 수 있음.<br/>
이 경우엔 상위 DNS 서버에 조회하면 하위 DNS 서버를 한 대 건너뛰고, 그 아래의 DNS 서버에 관한 정보가 반송됨.


#### DNS 서버는 캐시를 사용한다.
DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있음 <br/>
조회한 이름이 도메인에 등록되어 있지 않은 경우에도 캐시에 저장할 수 있어서 빠르게 회답할 수 있음. <br/>
케시에 저장한 후 정보가 바뀌는 경우도 있기 때문에 유효 기한을 설정하고 시간이 지나면 데이터가 삭제됨. <br />
또한, 응답 메세지를 보낼 때 정보가 DNS 서버에서 온 것인지 캐시 데이터에 저장된 값이 온 것인지 알려줌.

## 프로토콜 스택에 메세지 송신을 의뢰

IP 주소를 조사한 후, 대상 서버에 메세지를 송신하도록 OS 내부에 있는 프로토콜 스택에 의뢰함.<br/>
데이터를 송·수신할때도 IP 주소를 조회하는 것과 마찬가지로 소켓 라이브러리의 기능을 사용함.

### 데이터 송·수신의 과정
1. 소켓을 만든다. (소켓 작성 단계)
2. 서버 측의 소켓에 파이프를 연결한다. (접속 단계)
3. 데이터를 송·수신한다. (송·수신 단계)
4. 파이프를 분리하고 소켓을 말소한다. (연결 끊기 단계)

위 동작을 실행하는 것은 `프로토콜 스택`.<br/>
소켓 라이브러리는 의뢰받은 내용을 프로토콜 스택에 전달하는 역할임.

#### 소켓 작성 단계
1. 소켓 라이브러리의 'socket' 함수 호출
2. 소켓이 생성되면 `디스크립터`가 리턴됨
   - 소켓을 식별하기 위해 사용됨.

#### 접속 단계
1. 클라이언트 소켓이 서버 소켓과 연결하기 위해 'connect' 함수 호출
   - 매개변수로 디스크립터, 서버의 IP 주소, 포트번호 넘겨줌
      1. 디스크립터 : 소켓 만들 때 리턴받은 디스크립터
      2. IP 주소 : DNS 서버에서 조사한 IP 주소
      3. 포트번호 : 특정 서버 소켓에 연결할 때 목적지를 정확하게 식별하기 위해 사용함.
         - 미리 결정된 값 사용(`웹`: 80, `메일`: 25)
2. 연결되면 프로토콜 스택은 소켓에 IP 주소, 포트번호 등을 기록함.

#### 송·수신 단계
1. 'write' 함수를 이용해서 데이터 전송함.
   - 매개변수로 디스크립터, 송신 데이터, 송신 데이터 길이 넘겨줌
2. 서버가 응답 메세지 반송
3. 'read' 함수를 사용해 데이터 읽어옴
   - 매개변수로 `수신 버퍼` 넘겨줌
     - 수신 버퍼 : 응답메세지를 저장하기 위한 메모리 영역

#### 연결 끊기
1. 'close'를 이용하여 연결을 끊음(소켓 연결 종료 및 소켓 자원 해제)




